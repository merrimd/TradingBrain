trigger:
  branches:
    include:
      - main
  paths:
    exclude:
      - README.md
      - docs/*

pr:
  branches:
    include:
      - main
      - develop

parameters:
  - name: manualTrigger
    displayName: 'Manual Deployment'
    type: boolean
    default: false

variables:
  - name: REGISTRY
    value: 'ghcr.io'
  - name: IMAGE_NAME
    value: '$(Build.Repository.Name)'
  - name: AZURE_CONTAINER_APP_NAME
    value: 'tradingbrain-grid-test'
  - name: AZURE_RESOURCE_GROUP
    value: 'IGContainerGrp'
  - name: AZURE_CONTAINER_APP_ENVIRONMENT
    value: 'managedEnvironment-IGContainerGrp-93fe'
  # Test environment configuration
  - name: AZURE_CONTAINER_APP_NAME_TEST
    value: 'tradingbrain-grid-test'
  - name: AZURE_RESOURCE_GROUP_TEST
    value: 'IGContainerGrp'
  # Production environment configuration (update if different from test)
  - name: AZURE_CONTAINER_APP_NAME_PROD
    value: 'tradingbrain-grid-prod'  # Change this if you have a separate prod app
  - name: AZURE_RESOURCE_GROUP_PROD
    value: 'IGContainerGrp'  # Change this if you have a separate prod resource group
  - name: dotnetVersion
    value: '8.0.x'
  # BUILD ONLY TRADINGBRAIN PROJECT - IGNORE IGMODELS
  # This will build only the TradingBrain.csproj file and skip IGModels.csproj
  - name: buildPath
    value: '**/TradingBrain.csproj'

stages:
  # ============================================================================
  # Stage 1: Code Quality and Security Scanning
  # ============================================================================
  - stage: CodeQuality
    displayName: 'Code Quality & Security Scanning'
    jobs:
      - job: SecurityScanning
        displayName: 'Security & Quality Checks'
        pool:
          vmImage: 'ubuntu-latest'
        
        steps:
          - checkout: self
            fetchDepth: 0
            displayName: 'Checkout code with full history'

          - task: UseDotNet@2
            displayName: 'Setup .NET SDK'
            inputs:
              version: $(dotnetVersion)
              includePreviewVersions: false

          # Static code analysis
          - script: |
              # Find and format only TradingBrain.csproj
              PROJECT_FILE=$(find . -name "TradingBrain.csproj" -type f | head -1)
              
              if [ -z "$PROJECT_FILE" ]; then
                echo "##[warning]TradingBrain.csproj not found, skipping code linting"
                exit 0
              fi
              
              echo "Running code linting on: $PROJECT_FILE"
              dotnet format "$PROJECT_FILE" --verify-no-changes --verbosity diagnostic
            displayName: 'Run code linting'
            continueOnError: true

          # Dependency vulnerability scanning
          - script: |
              # Scan only TradingBrain.csproj for vulnerabilities
              PROJECT_FILE=$(find . -name "TradingBrain.csproj" -type f | head -1)
              
              if [ -z "$PROJECT_FILE" ]; then
                echo "##[warning]TradingBrain.csproj not found, skipping dependency scan"
                exit 0
              fi
              
              echo "Scanning dependencies for: $PROJECT_FILE"
              dotnet list "$PROJECT_FILE" package --vulnerable --include-transitive
            displayName: 'Run dependency vulnerability scan'
            continueOnError: true

          # For CodeQL in Azure DevOps, you would typically use:
          # Microsoft Security Code Analysis extension or GitHub Advanced Security for Azure DevOps
          # Alternative: SonarCloud or SonarQube
          - script: |
              # Build only TradingBrain.csproj for code analysis
              echo "Finding TradingBrain.csproj..."
              PROJECT_FILE=$(find . -name "TradingBrain.csproj" -type f | head -1)
              
              if [ -z "$PROJECT_FILE" ]; then
                echo "##[warning]TradingBrain.csproj not found"
                exit 0
              fi
              
              echo "Building for code analysis: $PROJECT_FILE"
              dotnet build "$PROJECT_FILE" --configuration Release
            displayName: 'Build TradingBrain for code analysis'
            continueOnError: true

          # Trivy vulnerability scanner
          - script: |
              # Install Trivy
              wget -qO - https://aquasecurity.github.io/trivy-repo/deb/public.key | sudo apt-key add -
              echo "deb https://aquasecurity.github.io/trivy-repo/deb $(lsb_release -sc) main" | sudo tee -a /etc/apt/sources.list.d/trivy.list
              sudo apt-get update
              sudo apt-get install trivy -y
              
              # Run Trivy scan
              trivy fs . --format sarif --output trivy-results.sarif --severity CRITICAL,HIGH
            displayName: 'Run Trivy vulnerability scanner'
            continueOnError: true

          # For SARIF upload, you can use the SARIF SAST Scans Tab extension
          - task: PublishBuildArtifacts@1
            displayName: 'Upload Trivy results'
            condition: always()
            inputs:
              PathtoPublish: 'trivy-results.sarif'
              ArtifactName: 'CodeAnalysisLogs'

  # ============================================================================
  # Stage 2: Build and Test
  # ============================================================================
  - stage: BuildAndTest
    displayName: 'Build and Test'
    dependsOn: CodeQuality
    condition: succeeded()
    jobs:
      - job: Build
        displayName: 'Build and Test Application'
        pool:
          vmImage: 'ubuntu-latest'
        
        steps:
          - checkout: self
            displayName: 'Checkout code'

          - task: UseDotNet@2
            displayName: 'Setup .NET SDK'
            inputs:
              version: $(dotnetVersion)

          # Diagnostic step to find TradingBrain project
          - script: |
              echo "=== Repository Structure ==="
              echo "Current directory: $(pwd)"
              echo ""
              echo "=== Looking for TradingBrain.csproj ==="
              find . -name "TradingBrain.csproj" -type f
              echo ""
              echo "=== All .csproj files (for reference) ==="
              find . -name "*.csproj" -type f
              echo ""
              echo "NOTE: Pipeline will ONLY build TradingBrain.csproj (IGModels will be ignored)"
            displayName: 'Find TradingBrain project'

          - script: |
              # Restore only TradingBrain.csproj dependencies
              echo "Finding TradingBrain.csproj..."
              PROJECT_FILE=$(find . -name "TradingBrain.csproj" -type f | head -1)
              
              if [ -z "$PROJECT_FILE" ]; then
                echo "##[error]TradingBrain.csproj not found!"
                exit 1
              fi
              
              echo "Found: $PROJECT_FILE"
              echo "Restoring dependencies for TradingBrain project only..."
              dotnet restore "$PROJECT_FILE"
            displayName: 'Restore TradingBrain dependencies'

          - script: |
              # Build only TradingBrain.csproj
              echo "Finding TradingBrain.csproj..."
              PROJECT_FILE=$(find . -name "TradingBrain.csproj" -type f | head -1)
              
              if [ -z "$PROJECT_FILE" ]; then
                echo "##[error]TradingBrain.csproj not found!"
                exit 1
              fi
              
              echo "Building: $PROJECT_FILE"
              dotnet build "$PROJECT_FILE" --configuration Release --no-restore
            displayName: 'Build TradingBrain project'

          - script: |
              # Test only TradingBrain.csproj (if tests exist)
              echo "Finding TradingBrain.csproj..."
              PROJECT_FILE=$(find . -name "TradingBrain.csproj" -type f | head -1)
              
              if [ -z "$PROJECT_FILE" ]; then
                echo "##[warning]TradingBrain.csproj not found, skipping tests"
                exit 0
              fi
              
              echo "Running tests for: $PROJECT_FILE"
              dotnet test "$PROJECT_FILE" --configuration Release --no-build --verbosity normal --collect:"XPlat Code Coverage" --logger trx
            displayName: 'Run unit tests'
            continueOnError: true

          - task: PublishTestResults@2
            displayName: 'Publish test results'
            condition: always()
            inputs:
              testResultsFormat: 'VSTest'
              testResultsFiles: '**/*.trx'
              mergeTestResults: true
              failTaskOnFailedTests: false

          - task: PublishCodeCoverageResults@2
            displayName: 'Publish code coverage'
            condition: always()
            inputs:
              codeCoverageTool: 'Cobertura'
              summaryFileLocation: '**/coverage.cobertura.xml'
              failIfCoverageEmpty: false

  # ============================================================================
  # Stage 3: Build Container Image
  # ============================================================================
  - stage: BuildContainer
    displayName: 'Build Container Image'
    dependsOn: BuildAndTest
    condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/main'))
    jobs:
      - job: ContainerBuild
        displayName: 'Build and Push Container'
        pool:
          vmImage: 'ubuntu-latest'
        
        steps:
          - checkout: self
            displayName: 'Checkout code'

          - task: Docker@2
            displayName: 'Docker Login to GHCR'
            inputs:
              command: 'login'
              containerRegistry: 'GitHubContainerRegistry'  # Service connection name

          - script: |
              # Prepare image tags
              REGISTRY="$(REGISTRY)"
              IMAGE_NAME="$(IMAGE_NAME)"
              
              # Make image name lowercase (GHCR requirement)
              IMAGE_NAME=$(echo "$IMAGE_NAME" | tr '[:upper:]' '[:lower:]')
              
              BRANCH_NAME=$(echo "$(Build.SourceBranchName)" | tr '[:upper:]' '[:lower:]')
              SHORT_SHA=$(echo "$(Build.SourceVersion)" | cut -c1-7)
              
              echo "Registry: $REGISTRY"
              echo "Image: $IMAGE_NAME"
              echo "Branch: $BRANCH_NAME"
              echo "SHA: $SHORT_SHA"
              
              # Set variables for next steps
              echo "##vso[task.setvariable variable=FULL_IMAGE_NAME]$REGISTRY/$IMAGE_NAME"
              echo "##vso[task.setvariable variable=IMAGE_TAG_V1]$REGISTRY/$IMAGE_NAME:v1"
              echo "##vso[task.setvariable variable=IMAGE_TAG_BRANCH]$REGISTRY/$IMAGE_NAME:$BRANCH_NAME"
              echo "##vso[task.setvariable variable=IMAGE_TAG_SHA]$REGISTRY/$IMAGE_NAME:$BRANCH_NAME-$SHORT_SHA"
              echo "##vso[task.setvariable variable=IMAGE_TAG_LATEST]$REGISTRY/$IMAGE_NAME:latest"
            displayName: 'Generate image tags'

          - script: |
              # Build the container image
              docker build \
                -t "$(IMAGE_TAG_V1)" \
                -t "$(IMAGE_TAG_LATEST)" \
                -t "$(IMAGE_TAG_BRANCH)" \
                -t "$(IMAGE_TAG_SHA)" \
                --build-arg BUILD_NUMBER=$(Build.BuildNumber) \
                -f Dockerfile \
                .
              
              echo "✅ Docker build completed successfully"
              echo ""
              echo "Built images with tags:"
              echo "  - $(IMAGE_TAG_V1)"
              echo "  - $(IMAGE_TAG_LATEST)"
              echo "  - $(IMAGE_TAG_BRANCH)"
              echo "  - $(IMAGE_TAG_SHA)"
            displayName: 'Build container image'

          - script: |
              # Push all tags
              echo "Pushing: $(IMAGE_TAG_V1)"
              docker push "$(IMAGE_TAG_V1)"
              
              echo "Pushing: $(IMAGE_TAG_LATEST)"
              docker push "$(IMAGE_TAG_LATEST)"
              
              echo "Pushing: $(IMAGE_TAG_BRANCH)"
              docker push "$(IMAGE_TAG_BRANCH)"
              
              echo "Pushing: $(IMAGE_TAG_SHA)"
              docker push "$(IMAGE_TAG_SHA)"
              
              echo "✅ All tags pushed successfully"
            displayName: 'Push container image to GHCR'

          # Scan the built container image
          - script: |
              # Install Trivy if not already installed
              wget -qO - https://aquasecurity.github.io/trivy-repo/deb/public.key | sudo apt-key add -
              echo "deb https://aquasecurity.github.io/trivy-repo/deb $(lsb_release -sc) main" | sudo tee -a /etc/apt/sources.list.d/trivy.list
              sudo apt-get update
              sudo apt-get install trivy -y
              
              # Scan the container image with v1 tag
              trivy image $(IMAGE_TAG_V1) --format sarif --output container-scan-results.sarif --severity CRITICAL,HIGH
            displayName: 'Scan container image with Trivy'
            continueOnError: true

          - task: PublishBuildArtifacts@1
            displayName: 'Upload container scan results'
            condition: always()
            inputs:
              PathtoPublish: 'container-scan-results.sarif'
              ArtifactName: 'ContainerSecurityScans'

          # Store image information for deployment stage
          - script: |
              echo "$(IMAGE_TAG_LATEST)" > $(Build.ArtifactStagingDirectory)/image-tag.txt
            displayName: 'Save image tag'

          - task: PublishPipelineArtifact@1
            displayName: 'Publish image metadata'
            inputs:
              targetPath: '$(Build.ArtifactStagingDirectory)/image-tag.txt'
              artifactName: 'image-metadata'

  # ============================================================================
  # Stage 4: Deploy to Test Environment (with Manual Approval)
  # ============================================================================
  - stage: DeployTest
    displayName: 'Deploy to Test Environment'
    dependsOn: BuildContainer
    condition: succeeded()
    jobs:
      - deployment: DeployToTest
        displayName: 'Deploy to Test Container Apps'
        pool:
          vmImage: 'ubuntu-latest'
        environment: 'test'  # This enables manual approval - configure in Environments
        strategy:
          runOnce:
            deploy:
              steps:
                - checkout: self
                  displayName: 'Checkout code'

                - task: DownloadPipelineArtifact@2
                  displayName: 'Download image metadata'
                  inputs:
                    artifactName: 'image-metadata'
                    targetPath: '$(Pipeline.Workspace)'

                - script: |
                    IMAGE_TAG=$(cat $(Pipeline.Workspace)/image-tag.txt)
                    echo "##vso[task.setvariable variable=DEPLOY_IMAGE_TAG]$IMAGE_TAG"
                    echo "Deploying image: $IMAGE_TAG"
                  displayName: 'Load image tag'

                - task: AzureCLI@2
                  displayName: 'Deploy to Test Environment'
                  inputs:
                    azureSubscription: 'AzureServiceConnection'
                    scriptType: 'bash'
                    scriptLocation: 'inlineScript'
                    inlineScript: |
                      echo "Deploying to TEST environment..."
                      echo "Container App: $(AZURE_CONTAINER_APP_NAME_TEST)"
                      echo "Resource Group: $(AZURE_RESOURCE_GROUP_TEST)"
                      echo "Image: $(DEPLOY_IMAGE_TAG)"
                      
                      az containerapp update \
                        --name $(AZURE_CONTAINER_APP_NAME_TEST) \
                        --resource-group $(AZURE_RESOURCE_GROUP_TEST) \
                        --image $(DEPLOY_IMAGE_TAG) \
                        --set-env-vars BUILD_NUMBER=$(Build.BuildNumber) ENVIRONMENT=test

                - task: AzureCLI@2
                  displayName: 'Verify test deployment'
                  inputs:
                    azureSubscription: 'AzureServiceConnection'
                    scriptType: 'bash'
                    scriptLocation: 'inlineScript'
                    inlineScript: |
                      REVISION=$(az containerapp show \
                        --name $(AZURE_CONTAINER_APP_NAME_TEST) \
                        --resource-group $(AZURE_RESOURCE_GROUP_TEST) \
                        --query "properties.latestRevisionName" \
                        --output tsv)
                      
                      echo "✅ Test deployment revision: $REVISION"
                      echo "##vso[task.setvariable variable=TEST_REVISION]$REVISION"

                - script: |
                    APP_URL="https://$(AZURE_CONTAINER_APP_NAME_TEST).azurecontainerapps.io"
                    echo "Testing deployment at $APP_URL"
                    
                    # Wait for deployment to stabilize
                    sleep 10
                    
                    HTTP_CODE=$(curl -f -s -o /dev/null -w "%{http_code}" $APP_URL/health || echo "000")
                    
                    if [ "$HTTP_CODE" == "200" ]; then
                      echo "✅ Test environment health check passed (HTTP $HTTP_CODE)"
                    else
                      echo "⚠️  Test environment health check returned HTTP $HTTP_CODE"
                      echo "This may be expected if /health endpoint doesn't exist"
                    fi
                  displayName: 'Run smoke tests on test environment'
                  continueOnError: true

                - script: |
                    echo "============================================"
                    echo "✅ TEST DEPLOYMENT SUCCESSFUL"
                    echo "============================================"
                    echo "Environment: TEST"
                    echo "Container App: $(AZURE_CONTAINER_APP_NAME_TEST)"
                    echo "Build: $(Build.BuildNumber)"
                    echo "Image: $(DEPLOY_IMAGE_TAG)"
                    echo "URL: https://$(AZURE_CONTAINER_APP_NAME_TEST).azurecontainerapps.io"
                    echo "============================================"
                  displayName: 'Test deployment summary'

  # ============================================================================
  # Stage 5: Deploy to Production (with Manual Approval)
  # ============================================================================
  - stage: DeployProduction
    displayName: 'Deploy to Production Environment'
    dependsOn: DeployTest
    condition: succeeded()
    jobs:
      - deployment: DeployToProduction
        displayName: 'Deploy to Production Container Apps'
        pool:
          vmImage: 'ubuntu-latest'
        environment: 'production'  # This enables manual approval - configure in Environments
        strategy:
          runOnce:
            deploy:
              steps:
                - checkout: self
                  displayName: 'Checkout code'

                - task: DownloadPipelineArtifact@2
                  displayName: 'Download image metadata'
                  inputs:
                    artifactName: 'image-metadata'
                    targetPath: '$(Pipeline.Workspace)'

                - script: |
                    IMAGE_TAG=$(cat $(Pipeline.Workspace)/image-tag.txt)
                    echo "##vso[task.setvariable variable=DEPLOY_IMAGE_TAG]$IMAGE_TAG"
                    echo "Deploying image: $IMAGE_TAG"
                  displayName: 'Load image tag'

                - task: AzureCLI@2
                  displayName: 'Deploy to Production Environment'
                  inputs:
                    azureSubscription: 'AzureServiceConnection'
                    scriptType: 'bash'
                    scriptLocation: 'inlineScript'
                    inlineScript: |
                      echo "Deploying to PRODUCTION environment..."
                      echo "Container App: $(AZURE_CONTAINER_APP_NAME_PROD)"
                      echo "Resource Group: $(AZURE_RESOURCE_GROUP_PROD)"
                      echo "Image: $(DEPLOY_IMAGE_TAG)"
                      
                      az containerapp update \
                        --name $(AZURE_CONTAINER_APP_NAME_PROD) \
                        --resource-group $(AZURE_RESOURCE_GROUP_PROD) \
                        --image $(DEPLOY_IMAGE_TAG) \
                        --set-env-vars BUILD_NUMBER=$(Build.BuildNumber) ENVIRONMENT=production

                - task: AzureCLI@2
                  displayName: 'Verify production deployment'
                  inputs:
                    azureSubscription: 'AzureServiceConnection'
                    scriptType: 'bash'
                    scriptLocation: 'inlineScript'
                    inlineScript: |
                      REVISION=$(az containerapp show \
                        --name $(AZURE_CONTAINER_APP_NAME_PROD) \
                        --resource-group $(AZURE_RESOURCE_GROUP_PROD) \
                        --query "properties.latestRevisionName" \
                        --output tsv)
                      
                      echo "✅ Production deployment revision: $REVISION"
                      echo "##vso[task.setvariable variable=PROD_REVISION]$REVISION"

                - script: |
                    APP_URL="https://$(AZURE_CONTAINER_APP_NAME_PROD).azurecontainerapps.io"
                    echo "Testing deployment at $APP_URL"
                    
                    # Wait for deployment to stabilize
                    sleep 10
                    
                    HTTP_CODE=$(curl -f -s -o /dev/null -w "%{http_code}" $APP_URL/health || echo "000")
                    
                    if [ "$HTTP_CODE" == "200" ]; then
                      echo "✅ Production health check passed (HTTP $HTTP_CODE)"
                    else
                      echo "❌ Production health check failed (HTTP $HTTP_CODE)"
                      exit 1
                    fi
                  displayName: 'Run smoke tests on production'
                  continueOnError: false

                - script: |
                    echo "============================================"
                    echo "✅ PRODUCTION DEPLOYMENT SUCCESSFUL"
                    echo "============================================"
                    echo "Environment: PRODUCTION"
                    echo "Container App: $(AZURE_CONTAINER_APP_NAME_PROD)"
                    echo "Build: $(Build.BuildNumber)"
                    echo "Image: $(DEPLOY_IMAGE_TAG)"
                    echo "URL: https://$(AZURE_CONTAINER_APP_NAME_PROD).azurecontainerapps.io"
                    echo "============================================"
                  displayName: 'Production deployment summary'

  # ============================================================================
  # Stage 6: Post-Deployment Notification
  # ============================================================================
  - stage: Notify
    displayName: 'Deployment Notification'
    dependsOn: 
      - DeployTest
      - DeployProduction
    condition: always()
    jobs:
      - job: NotifyStatus
        displayName: 'Send Deployment Status'
        pool:
          vmImage: 'ubuntu-latest'
        variables:
          testStatus: $[ stageDependencies.DeployTest.DeployToTest.result ]
          prodStatus: $[ stageDependencies.DeployProduction.DeployToProduction.result ]
        
        steps:
          - script: |
              echo "============================================"
              echo "DEPLOYMENT PIPELINE SUMMARY"
              echo "============================================"
              echo "Build Number: $(Build.BuildNumber)"
              echo "Test Environment: $(testStatus)"
              echo "Production Environment: $(prodStatus)"
              echo "============================================"
              
              if [ "$(testStatus)" == "Succeeded" ] && [ "$(prodStatus)" == "Succeeded" ]; then
                echo "✅ All deployments successful!"
                echo ""
                echo "Test URL: https://$(AZURE_CONTAINER_APP_NAME_TEST).azurecontainerapps.io"
                echo "Production URL: https://$(AZURE_CONTAINER_APP_NAME_PROD).azurecontainerapps.io"
              elif [ "$(testStatus)" == "Succeeded" ] && [ "$(prodStatus)" != "Succeeded" ]; then
                echo "⚠️  Test deployment succeeded, but production failed or was skipped"
              elif [ "$(testStatus)" != "Succeeded" ]; then
                echo "❌ Test deployment failed - production was not attempted"
                exit 1
              else
                echo "❌ Deployment pipeline encountered issues"
                exit 1
              fi
            displayName: 'Deployment notification'

          # Optional: Add notification tasks here
          # - task: SendEmail@1
          #   inputs:
          #     To: 'team@example.com'
          #     Subject: 'Deployment $(testStatus) - Build $(Build.BuildNumber)'
          #     Body: 'Test: $(testStatus), Production: $(prodStatus)'
          # 
          # - task: SlackNotification@1
          #   inputs:
          #     SlackApiToken: '$(SLACK_TOKEN)'
          #     Channel: '#deployments'
          #     Message: 'Deployment completed - Test: $(testStatus), Prod: $(prodStatus)'
          # 
          # - task: MicrosoftTeamsNotification@1
          #   inputs:
          #     WebhookUrl: '$(TEAMS_WEBHOOK)'
          #     Message: 'Pipeline $(Build.BuildNumber) - Test: $(testStatus), Prod: $(prodStatus)'

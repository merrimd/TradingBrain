trigger:
  branches:
    include:
      - main
  paths:
    exclude:
      - README.md
      - docs/*

pr:
  branches:
    include:
      - main
      - develop

parameters:
  - name: manualTrigger
    displayName: 'Manual Deployment'
    type: boolean
    default: false

variables:
  - name: REGISTRY
    value: 'IContainerReg.azurecr.io'
  - name: IMAGE_NAME
    value: 'tradingbrain-grid-test'
  - name: AZURE_CONTAINER_APP_NAME
    value: 'tradingbrain-grid-test'
  - name: AZURE_RESOURCE_GROUP
    value: 'IGContainerGrp'
  - name: AZURE_CONTAINER_APP_ENVIRONMENT
    value: 'managedEnvironment-IGContainerGrp-93fe'
  - name: dotnetVersion
    value: '8.0.x'
  # BUILD ONLY TRADINGBRAIN PROJECT - IGNORE IGMODELS
  # This will build only the TradingBrain.csproj file and skip IGModels.csproj
  - name: buildPath
    value: '**/TradingBrain.csproj'

stages:
  # ============================================================================
  # Stage 1: Code Quality and Security Scanning
  # ============================================================================
  - stage: CodeQuality
    displayName: 'Code Quality & Security Scanning'
    jobs:
      - job: SecurityScanning
        displayName: 'Security & Quality Checks'
        pool:
          vmImage: 'ubuntu-latest'
        
        steps:
          - checkout: self
            fetchDepth: 0
            displayName: 'Checkout code with full history'

          - task: UseDotNet@2
            displayName: 'Setup .NET SDK'
            inputs:
              version: $(dotnetVersion)
              includePreviewVersions: false

          # Static code analysis
          - script: |
              # Find and format only TradingBrain.csproj
              PROJECT_FILE=$(find . -name "TradingBrain.csproj" -type f | head -1)
              
              if [ -z "$PROJECT_FILE" ]; then
                echo "##[warning]TradingBrain.csproj not found, skipping code linting"
                exit 0
              fi
              
              echo "Running code linting on: $PROJECT_FILE"
              dotnet format "$PROJECT_FILE" --verify-no-changes --verbosity diagnostic
            displayName: 'Run code linting'
            continueOnError: true

          # Dependency vulnerability scanning
          - script: |
              # Scan only TradingBrain.csproj for vulnerabilities
              PROJECT_FILE=$(find . -name "TradingBrain.csproj" -type f | head -1)
              
              if [ -z "$PROJECT_FILE" ]; then
                echo "##[warning]TradingBrain.csproj not found, skipping dependency scan"
                exit 0
              fi
              
              echo "Scanning dependencies for: $PROJECT_FILE"
              dotnet list "$PROJECT_FILE" package --vulnerable --include-transitive
            displayName: 'Run dependency vulnerability scan'
            continueOnError: true

          # For CodeQL in Azure DevOps, you would typically use:
          # Microsoft Security Code Analysis extension or GitHub Advanced Security for Azure DevOps
          # Alternative: SonarCloud or SonarQube
          - script: |
              # Build only TradingBrain.csproj for code analysis
              echo "Finding TradingBrain.csproj..."
              PROJECT_FILE=$(find . -name "TradingBrain.csproj" -type f | head -1)
              
              if [ -z "$PROJECT_FILE" ]; then
                echo "##[warning]TradingBrain.csproj not found"
                exit 0
              fi
              
              echo "Building for code analysis: $PROJECT_FILE"
              dotnet build "$PROJECT_FILE" --configuration Release
            displayName: 'Build TradingBrain for code analysis'
            continueOnError: true

          # Trivy vulnerability scanner
          - script: |
              # Install Trivy
              wget -qO - https://aquasecurity.github.io/trivy-repo/deb/public.key | sudo apt-key add -
              echo "deb https://aquasecurity.github.io/trivy-repo/deb $(lsb_release -sc) main" | sudo tee -a /etc/apt/sources.list.d/trivy.list
              sudo apt-get update
              sudo apt-get install trivy -y
              
              # Run Trivy scan
              trivy fs . --format sarif --output trivy-results.sarif --severity CRITICAL,HIGH
            displayName: 'Run Trivy vulnerability scanner'
            continueOnError: true

          # For SARIF upload, you can use the SARIF SAST Scans Tab extension
          - task: PublishBuildArtifacts@1
            displayName: 'Upload Trivy results'
            condition: always()
            inputs:
              PathtoPublish: 'trivy-results.sarif'
              ArtifactName: 'CodeAnalysisLogs'

  # ============================================================================
  # Stage 2: Build and Test
  # ============================================================================
  - stage: BuildAndTest
    displayName: 'Build and Test'
    dependsOn: CodeQuality
    condition: succeeded()
    jobs:
      - job: Build
        displayName: 'Build and Test Application'
        pool:
          vmImage: 'ubuntu-latest'
        
        steps:
          - checkout: self
            displayName: 'Checkout code'

          - task: UseDotNet@2
            displayName: 'Setup .NET SDK'
            inputs:
              version: $(dotnetVersion)

          # Diagnostic step to find TradingBrain project
          - script: |
              echo "=== Repository Structure ==="
              echo "Current directory: $(pwd)"
              echo ""
              echo "=== Looking for TradingBrain.csproj ==="
              find . -name "TradingBrain.csproj" -type f
              echo ""
              echo "=== All .csproj files (for reference) ==="
              find . -name "*.csproj" -type f
              echo ""
              echo "NOTE: Pipeline will ONLY build TradingBrain.csproj (IGModels will be ignored)"
            displayName: 'Find TradingBrain project'

          - script: |
              # Restore only TradingBrain.csproj dependencies
              echo "Finding TradingBrain.csproj..."
              PROJECT_FILE=$(find . -name "TradingBrain.csproj" -type f | head -1)
              
              if [ -z "$PROJECT_FILE" ]; then
                echo "##[error]TradingBrain.csproj not found!"
                exit 1
              fi
              
              echo "Found: $PROJECT_FILE"
              echo "Restoring dependencies for TradingBrain project only..."
              dotnet restore "$PROJECT_FILE"
            displayName: 'Restore TradingBrain dependencies'

          - script: |
              # Build only TradingBrain.csproj
              echo "Finding TradingBrain.csproj..."
              PROJECT_FILE=$(find . -name "TradingBrain.csproj" -type f | head -1)
              
              if [ -z "$PROJECT_FILE" ]; then
                echo "##[error]TradingBrain.csproj not found!"
                exit 1
              fi
              
              echo "Building: $PROJECT_FILE"
              dotnet build "$PROJECT_FILE" --configuration Release --no-restore
            displayName: 'Build TradingBrain project'

          - script: |
              # Test only TradingBrain.csproj (if tests exist)
              echo "Finding TradingBrain.csproj..."
              PROJECT_FILE=$(find . -name "TradingBrain.csproj" -type f | head -1)
              
              if [ -z "$PROJECT_FILE" ]; then
                echo "##[warning]TradingBrain.csproj not found, skipping tests"
                exit 0
              fi
              
              echo "Running tests for: $PROJECT_FILE"
              dotnet test "$PROJECT_FILE" --configuration Release --no-build --verbosity normal --collect:"XPlat Code Coverage" --logger trx
            displayName: 'Run unit tests'
            continueOnError: true

          - task: PublishTestResults@2
            displayName: 'Publish test results'
            condition: always()
            inputs:
              testResultsFormat: 'VSTest'
              testResultsFiles: '**/*.trx'
              mergeTestResults: true
              failTaskOnFailedTests: false

          - task: PublishCodeCoverageResults@2
            displayName: 'Publish code coverage'
            condition: always()
            inputs:
              codeCoverageTool: 'Cobertura'
              summaryFileLocation: '**/coverage.cobertura.xml'
              failIfCoverageEmpty: false

  # ============================================================================
  # Stage 3: Build Container Image
  # ============================================================================
  - stage: BuildContainer
    displayName: 'Build Container Image'
    dependsOn: BuildAndTest
    condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/main'))
    jobs:
      - job: ContainerBuild
        displayName: 'Build and Push Container'
        pool:
          vmImage: 'ubuntu-latest'
        
        steps:
          - checkout: self
            displayName: 'Checkout code'

          - task: Docker@2
            displayName: 'Docker Login to GHCR'
            inputs:
              command: 'login'
              containerRegistry: 'AzureContainerRegistry'  # Service connection name

          - script: |
              # Prepare image tags
              REGISTRY="$(REGISTRY)"
              IMAGE_NAME="$(IMAGE_NAME)"
              
              # Make image name lowercase (GHCR requirement)
              IMAGE_NAME=$(echo "$IMAGE_NAME" | tr '[:upper:]' '[:lower:]')
              
              BRANCH_NAME=$(echo "$(Build.SourceBranchName)" | tr '[:upper:]' '[:lower:]')
              SHORT_SHA=$(echo "$(Build.SourceVersion)" | cut -c1-7)
              
              echo "Registry: $REGISTRY"
              echo "Image: $IMAGE_NAME"
              echo "Branch: $BRANCH_NAME"
              echo "SHA: $SHORT_SHA"
              
              # Set variables for next steps
              echo "##vso[task.setvariable variable=FULL_IMAGE_NAME]$REGISTRY/$IMAGE_NAME"
              echo "##vso[task.setvariable variable=IMAGE_TAG_BRANCH]$REGISTRY/$IMAGE_NAME:$BRANCH_NAME"
              echo "##vso[task.setvariable variable=IMAGE_TAG_SHA]$REGISTRY/$IMAGE_NAME:$BRANCH_NAME-$SHORT_SHA"
              echo "##vso[task.setvariable variable=IMAGE_TAG_LATEST]$REGISTRY/$IMAGE_NAME:latest"
            displayName: 'Generate image tags'

          - script: |
              # Build the container image
              docker build \
                -t "$(IMAGE_TAG_LATEST)" \
                -t "$(IMAGE_TAG_BRANCH)" \
                -t "$(IMAGE_TAG_SHA)" \
                --build-arg BUILD_NUMBER=$(Build.BuildNumber) \
                -f Dockerfile \
                .
              
              echo "Built images:"
              docker images | grep "$(IMAGE_NAME)"
            displayName: 'Build container image'

          - script: |
              # Push all tags
              echo "Pushing: $(IMAGE_TAG_LATEST)"
              docker push "$(IMAGE_TAG_LATEST)"
              
              echo "Pushing: $(IMAGE_TAG_BRANCH)"
              docker push "$(IMAGE_TAG_BRANCH)"
              
              echo "Pushing: $(IMAGE_TAG_SHA)"
              docker push "$(IMAGE_TAG_SHA)"
              
              echo "All tags pushed successfully"
            displayName: 'Push container image to GHCR'

          # Scan the built container image
          - script: |
              # Install Trivy if not already installed
              wget -qO - https://aquasecurity.github.io/trivy-repo/deb/public.key | sudo apt-key add -
              echo "deb https://aquasecurity.github.io/trivy-repo/deb $(lsb_release -sc) main" | sudo tee -a /etc/apt/sources.list.d/trivy.list
              sudo apt-get update
              sudo apt-get install trivy -y
              
              # Scan the container image
              trivy image $(REGISTRY)/$(IMAGE_NAME):latest --format sarif --output container-scan-results.sarif --severity CRITICAL,HIGH
            displayName: 'Scan container image with Trivy'
            continueOnError: true

          - task: PublishBuildArtifacts@1
            displayName: 'Upload container scan results'
            condition: always()
            inputs:
              PathtoPublish: 'container-scan-results.sarif'
              ArtifactName: 'ContainerSecurityScans'

          # Store image information for deployment stage
          - script: |
              echo "$(IMAGE_TAG_LATEST)" > $(Build.ArtifactStagingDirectory)/image-tag.txt
            displayName: 'Save image tag'

          - task: PublishPipelineArtifact@1
            displayName: 'Publish image metadata'
            inputs:
              targetPath: '$(Build.ArtifactStagingDirectory)/image-tag.txt'
              artifactName: 'image-metadata'

  # ============================================================================
  # Stage 4: Manual Approval & Deploy to Azure
  # ============================================================================
  - stage: Deploy
    displayName: 'Deploy to Production'
    dependsOn: BuildContainer
    condition: succeeded()
    jobs:
      - deployment: DeployToAzure
        displayName: 'Deploy to Azure Container Apps'
        pool:
          vmImage: 'ubuntu-latest'
        environment: 'production'  # This enables manual approval in Azure DevOps
        strategy:
          runOnce:
            deploy:
              steps:
                - checkout: self
                  displayName: 'Checkout code'

                - task: DownloadPipelineArtifact@2
                  displayName: 'Download image metadata'
                  inputs:
                    artifactName: 'image-metadata'
                    targetPath: '$(Pipeline.Workspace)'

                - script: |
                    IMAGE_TAG=$(cat $(Pipeline.Workspace)/image-tag.txt)
                    echo "##vso[task.setvariable variable=DEPLOY_IMAGE_TAG]$IMAGE_TAG"
                  displayName: 'Load image tag'

                - task: AzureCLI@2
                  displayName: 'Azure Login and Deploy'
                  inputs:
                    azureSubscription: 'AzureServiceConnection'  # Service connection name
                    scriptType: 'bash'
                    scriptLocation: 'inlineScript'
                    inlineScript: |
                      # Deploy to Azure Container Apps
                      az containerapp update \
                        --name $(AZURE_CONTAINER_APP_NAME) \
                        --resource-group $(AZURE_RESOURCE_GROUP) \
                        --image $(DEPLOY_IMAGE_TAG) \
                        --set-env-vars BUILD_NUMBER=$(Build.BuildNumber)

                - task: AzureCLI@2
                  displayName: 'Verify deployment'
                  inputs:
                    azureSubscription: 'AzureServiceConnection'
                    scriptType: 'bash'
                    scriptLocation: 'inlineScript'
                    inlineScript: |
                      REVISION=$(az containerapp show \
                        --name $(AZURE_CONTAINER_APP_NAME) \
                        --resource-group $(AZURE_RESOURCE_GROUP) \
                        --query "properties.latestRevisionName" \
                        --output tsv)
                      
                      echo "Latest revision: $REVISION"
                      echo "##vso[task.setvariable variable=LATEST_REVISION]$REVISION"

                - script: |
                    APP_URL="https://$(AZURE_CONTAINER_APP_NAME).azurecontainerapps.io"
                    echo "Testing deployment at $APP_URL"
                    
                    HTTP_CODE=$(curl -f -s -o /dev/null -w "%{http_code}" $APP_URL/health)
                    
                    if [ $HTTP_CODE -eq 200 ]; then
                      echo "✅ Health check passed (HTTP $HTTP_CODE)"
                    else
                      echo "❌ Health check failed (HTTP $HTTP_CODE)"
                      exit 1
                    fi
                  displayName: 'Run smoke tests'

  # ============================================================================
  # Stage 5: Post-Deployment Notification
  # ============================================================================
  - stage: Notify
    displayName: 'Deployment Notification'
    dependsOn: Deploy
    condition: always()
    jobs:
      - job: NotifyStatus
        displayName: 'Send Deployment Status'
        pool:
          vmImage: 'ubuntu-latest'
        variables:
          deployStatus: $[ stageDependencies.Deploy.DeployToAzure.result ]
        
        steps:
          - script: |
              if [ "$(deployStatus)" == "Succeeded" ]; then
                echo "✅ Deployment successful"
                echo "Build: $(Build.BuildNumber)"
                echo "Environment: production"
              else
                echo "❌ Deployment failed or was skipped"
                echo "Status: $(deployStatus)"
                exit 1
              fi
            displayName: 'Deployment notification'

          # Optional: Add notification tasks here
          # - task: SendEmail@1
          # - task: SlackNotification@1
          # - task: MicrosoftTeamsNotification@1
